"""
Created on Nov 9, 2018

@author: bry
"""

# For use in serialization and de-serialization to json
import sys
from collections import OrderedDict
from typing import Any, Dict
import numpy as np
import numpy.typing as npt
from numpy import inf

from .includes import utilities
from . import data_load_store
from .includes import field_operations

# This is the version of the structure that's supported.
PATTERNS_VERSION = 1


class Patterns:
    """
    Main Patterns class. An object of this class contains a list of
    ``Patterns`` with each member of the list being an ordered dictionary
    object.

    Attributes:
        comment_static_vars (str): Comment string used as a header in the \
            JSON file export. Variables in this section are static.
        version (float): version of the ``Patterns`` structure
        comment_auto_populated (str): Comment string used as a header in the \
            JSON file export. Variables in this section are autogenerated \
            from file imports.
        Patterns (dict): primary list holding the patter data
    """

    def __init__(self):
        """
        Initialization method - creates empty structure with no Patterns.
        """
        self.version = PATTERNS_VERSION

        self.patterns = []

    def __get_raw_field_data(self, pat_ind: int) -> npt.ArrayLike:
        """
        Warning:
            This is a private method and is NOT intended for external use.

        This method is used to fetch the raw Etheta and Ephi fields from the
        imported data and applied permanent manipulations. It uses geometric
        definition of alpha, beta, psi angles or yaw, pitch roll angles
        correspondingly to apply permanent rotation. The fixed XYZ coordinate
        system is the same used to define the radiation pattern in spherical
        coordinates.

        Arguments:
            pat_ind (int): The pattern index to requested. Permanent rotation \
                is based on the three Euler angles defined in ``rot_offset``.

        Returns:
            ff (array): returns ``ff`` and if there is non-zero rotation \
                offset a rotated ``ff``
        """
        temp_pat = self.patterns[pat_ind]["ff"]
        rot_angles = self.patterns[pat_ind]["rot_offset"]
        temp_pat = field_operations.rotate(temp_pat, rot_angles)

        return temp_pat

    def __get_multiple_raw_fields_data(self, pat_inds: list):
        """
        Warning:
            This is a private method and is NOT intended for external use.

        Same as ``__get_raw_field_data`` but ``pat_inds`` is a list and the
        output is also a list

        Arguments:
            pat_ind (int): The pattern index to requested. Permanent rotation \
                is based on the three Euler angles defined in ``rot_offset``.

        Returns:
            ff (array): returns ``ff`` and if there is non-zero rotation \
                offset a rotated ``ff``
        """
        temp_pat = []
        for curr_p in pat_inds:
            temp_pat.append(self.__get_raw_field_data(curr_p))

        return temp_pat

    def __get_interp_mesh_from_patterns(self, pat_inds):
        """
        Warning:
            This is a private method and is NOT intended for external use.

        This method scans the Patterns listed under ``pat_inds`` and finds \
            the finest theta and phi angular resolution. From that it defines \
            interpolation parameters so that all Patterns in those indexes \
            can be interpolated to that finest resolution.

        Arguments:
            pat_inds (list): list of indexes of Patterns to be interpolated

        Returns:
            tuple: a tuple consisting of:

            - interp_vth (list): interpolation theta matrix generated with \
                meshgrid. The number of rows is the number of samples from \
                equally dividing the theta angle span with the smallest theta \
                step among all pattern indexes. The number of columns is \
                equal to the number of samples when diving the phi range \
                equally with eh smallest phi step.

            - interp_vph (list): interpolation phi matrix generated with \
                meshgrid. Same definitions as ``interp_vth``.

            - no_th_samples (int): number of theta samples

            - no_ph_samples (int): number of phi samples
        """
        min_th_step = np.min([self.patterns[curr_p]["th_step"] for curr_p in pat_inds])
        min_ph_step = np.min([self.patterns[curr_p]["ph_step"] for curr_p in pat_inds])
        interp_vth = np.array(range(0, 180 + min_th_step, min_th_step)) * np.pi / 180
        interp_vph = np.array(range(0, 360 + min_ph_step, min_ph_step)) * np.pi / 180

        return interp_vth, interp_vph

    def __get_interp_mesh(self, resolution=None, pat_inds=None):
        """
        Creates interpolation mesh based on either a set of input pattern
        indexes ``pat_inds`` or directly specifying the resolution
        ``resolution``.
        """
        if resolution is None:
            resolution = "auto"
            if pat_inds is None:
                sys.exit(
                    "If interpolation resolution is empty then pattern indexes MUST be \
                                            specified"
                )

        if resolution == "auto":
            interp_vth, interp_vph = self.__get_interp_mesh_from_patterns(pat_inds)
        else:
            interp_vth = (
                np.array(range(0, 180 + resolution[0], resolution[1])) * np.pi / 180
            )
            interp_vph = (
                np.array(range(0, 360 + resolution[1], resolution[1])) * np.pi / 180
            )

        interp_vth, interp_vph = np.meshgrid(interp_vth, interp_vph)

        return [interp_vth, interp_vph]

    def __interpolate(self, pat_inds, interp_resolution=None):
        interp_v = self.__get_interp_mesh(interp_resolution, pat_inds)
        temp_fields = []
        for curr_p in pat_inds:
            far_field = self.__get_raw_field_data(curr_p)
            pat_resolution = [
                self.patterns[curr_p]["th_step"],
                self.patterns[curr_p]["ph_step"],
            ]
            far_field = field_operations.interpolate_complex_field(
                interp_v, far_field, pat_resolution
            )

            temp_fields.append(far_field)
        return temp_fields

    def __create_legends(self, pat_ind):
        """
        Creates legend string for the pattern index.
        """
        context = self.get_context(pat_ind)
        legend = (
            str(context["Frequency [Hz]"] / 1e6)
            + " MHz @Port:"
            + str(context["Port [#]"])
            + "; File: "
            + str(context["File"])
            + "; Source: "
            + str(context["Source"])
        )

        return legend

    def __get_single_group_stats(
        self, members, field="Gabs", analysis_range=None, rot_angles=None
    ):
        t_stats = []
        for mem in members:
            t_stats.append(self.get_field_stats(mem, field, analysis_range, rot_angles))
        t_stats = np.array(t_stats)
        return t_stats

    def load_data(self, input_type, input_file_or_folder):
        """
        Loads Patterns from various input formats.

        Arguments:
            input_type (str): this parameter indicates the type of the \
                import. Possible values are:
                - json - loads from previously exported JSON file. This \
                    type of input requires a file path.
                - AAU_Legacy - Loads from old AAU chamber CSV file generated \
                    by the triggered Keysight VNA. This type of input \
                    requires a file path.
                - AAU_Satimo - loads from AAU's Satimo chamber file exports. \
                    This type of input requires a file path.
                - AAU_Colossus - loads from AAU's new big chamber file \
                    exports. This type of input requires a file path.
                - CST_File - loads from a CST exported pattern. This type of \
                    input requires a file path.
                - CST_Folder - Loads all CST exported files in a folder. \
                    This type of input requires a folder path.
                - CST_Par_Sweep - Loads all files in all folders part of a \
                    cached parameter sweep in CST. This type of input \
                    requires a folder path.
            input_file_or_folder (str): full file or folder path depending \
                on ``input_type``.

        Returns:
            bool: returns zero on successful completion. All Patterns \
                loaded from any source are appended.

        """
        data_load_store.check_load_data_input(input_type, input_file_or_folder)
        if input_type == "json":
            self = data_load_store.load_from_json(self, input_file_or_folder)

        elif input_type == "AAU_Legacy":
            patterns = data_load_store.load_from_aau_legacy(input_file_or_folder)
            self.patterns.extend(patterns)

        elif input_type == "AAU_Satimo":
            self = data_load_store.load_from_aau_satimo(self, input_file_or_folder)

        elif input_type == "AAU_Colossus":
            self = data_load_store.load_from_aau_aau_colossus(
                self, input_file_or_folder
            )

        elif input_type == "CST_File":
            new_pat = data_load_store.load_from_cst_file(input_file_or_folder)
            self.patterns.append(new_pat)

        elif input_type == "CST_Folder":
            patterns = data_load_store.load_from_cst_folder(input_file_or_folder)
            self.patterns.extend(patterns)

        elif input_type == "CST_Par_Sweep":
            self = data_load_store.load_from_cst_par_sweep(self, input_file_or_folder)

        return 0

    def get_context(self, pat_ind):
        """
        Get the context of the current pattern index

        Arguments:
            pat_ind (int): the index of the pattern to query. Single value \
                only possible. If multiple contexts required run a loop \
                and call this function multiple times.

        Returns:
            context (dict): returns an ordered dictionary with pattern \
                context. The output is the same as the ``Patterns`` \
                structure except it omits the ``ff`` parameter.
        """
        context = OrderedDict()
        context["Source"] = self.patterns[pat_ind]["source"]
        context["File"] = self.patterns[pat_ind]["file"]
        context["Frequency [Hz]"] = self.patterns[pat_ind]["frequency"]
        context["Port [#]"] = self.patterns[pat_ind]["port"]
        context["TH_Step [deg]"] = self.patterns[pat_ind]["th_step"]
        context["PH_Step [deg]"] = self.patterns[pat_ind]["ph_step"]
        context["Rot. Offset"] = self.patterns[pat_ind]["rot_offset"]
        return context

    def fetch_field_with_context(
        self, pat_ind, field="Gabs", field_format="dB", rot_angles=None
    ):
        """
        Same behavior as :meth:`~includes.patterns.Patterns.fetch_field`
        but with an additional context output.
        """
        temp_field, temp_phase = self.fetch_field(
            pat_ind, field, field_format, rot_angles
        )
        context = self.get_context(pat_ind)
        return temp_field, temp_phase, context

    def fetch_field(
        self,
        pat_ind: int,
        field: str = "Gabs",
        field_format: str = "dB",
        rot_angles: list[int] = None,
    ) -> tuple[npt.ArrayLike, npt.ArrayLike]:
        """
        Fetches the ``field`` at an index ``pat_ind`` in the ``field_format`` \
        and ``rotation`` specified. All fields are stored as E_theta and
        E_phi complex matrixes and this function makes the necessary
        conversions.

        Standard spherical coordinate system and angular rotations of
        antenna are defined in [IEEESTDTerms]_ and [IEEESTDTest]_.

        Arguments:
            pat_ind (int): The index of the pattern requested.

            field (str): the type of field requested. If the requested \
                field is different from the default complex E fields the \
                function converts it as necessary. See \
                :func:`~includes.field_operations.convert_field` for \
                list of possible values.

            field_format (str): The format of the output field. Definitions \
                are according to the Touchstone file format. See \
                :func:`~includes.field_operations.convert_field_format`\
                 for details on options.

            rot_angles (int,int,int): list of three Euler rotation \
                angles describing the rotation.\
                The definitions are according to [IEEESTDTest]_. The order \
                is --> [yaw, pitch, roll] \
                as defined in [IEEESTDTest]_. Default are set to zero.

        Returns:
            tuple: tuple containing:

                field (list): a two dimensional array containing the \
                    theta/phi values of the field \
                    along the columns and rows correspondingly. The number \
                    columns/rows corresponds\
                    to the pattern resolution along the theta and phi angles.

                phase (list): a two dimensional array containing the \
                    theta/phi values of the field\
                    phase along the columns and rows correspondingly. \
                    The number columns/rows\
                    corresponds to the pattern resolution along the theta \
                    and phi angles. See field\
                    definitions above for when phase is defined. When phase \
                    is NOT defined an empty\
                    list is returned.
        """

        temp_pat = self.__get_raw_field_data(pat_ind)

        temp_pat = field_operations.rotate(temp_pat, rot_angles)

        temp_field, temp_phase = field_operations.convert_field(
            field, field_format, temp_pat
        )

        return temp_field, temp_phase

    def get_point_on_sphere(
        self,
        pat_ind: int,
        field: str = "Gabs",
        field_format: str = "dB",
        direction: list[float] = [0, 0],
        interp_resolution: list[int] = None,
    ) -> tuple[float, float]:
        far_fields = self.__interpolate([pat_ind], interp_resolution)
        t_field, t_phase = field_operations.convert_field(
            field, field_format, far_fields[0]
        )
        # working with closed sphere here so that 360th degree can be
        # directly requested
        vth, vph = utilities.get_angle_vectors(
            t_field, sphere_type="closed", return_mesh=False
        )

        th_angle = vth[
            min(range(len(vth)), key=lambda i: abs(vth[i] - np.deg2rad(direction[0])))
        ]
        th_index = np.where(vth == th_angle)

        ph_angle = vph[
            min(range(len(vph)), key=lambda i: abs(vph[i] - np.deg2rad(direction[1])))
        ]
        ph_index = np.where(vph == ph_angle)

        result_field = t_field[th_index, ph_index]
        if t_phase.size != 0:
            result_phase = t_phase[th_index, ph_index]
        else:
            result_phase = 0

        return float(result_field), float(result_phase)

    def generate_analytical_pattern(
        self, input_parameters: Dict[str, Any] = None
    ) -> None:
        """
        Creates an analytical antenna pattern.

        Args:
            input_parameters (dict): python dictionary of parameters. See \
                :func:`~includes.data_load_store.get_analytical_parameters` \
                for details.

        Returns:
            None: The new pattern is appended to the list of Patterns.
        """
        self = data_load_store.generate_analytical_pattern(self, input_parameters)

    def get_tot_field_power(
        self, pat_ind: int, field: str, rot_angles: list[int] = None
    ) -> float:
        """
        This function calculates the total field power by integrating \
        over the entire sphere. The interpretation of the result depends \
        on the field being integrated. This operation is NOT defined for AR.

        Arguments:
            pat_ind (int): specifies the index of the patter to be \
                processed. Single value input\
                only possible. If multiple Patterns need be processed run a \
                loop and call this\
                function multiple times.
            field (str): specifies the field to be processed as a string \
                input as defined for\
                :meth:`~includes.patterns.Patterns.fetch_field`. \
                Field power is NOT defined for AR.
            rot_angles (:obj:`list` of three :obj:`int`): list of rotation \
                angles for the field. \
                Rotation alone should not impact total field power however \
                some numerical \
                inaccuracies can occur. See \
                :func:`~includes.field_operations.rotate` for details.

        Returns:
            float: Returns the 3D integrated total field power in linear \
                scale. If AR is selected returns and empty list.
        """

        # For efficiency always get the G field
        if field == "Gabs" or field == "Eabs":
            eff_field = "Gabs"
        elif field == "Gth" or field == "Eth":
            eff_field = "Gth"
        elif field == "Gph" or field == "Eph":
            eff_field = "Gph"
        elif field == "GL" or field == "EL":
            eff_field = "GL"
        elif field == "GR" or field == "ER":
            eff_field = "GR"
        elif field == "AR":
            eff_field = "AR"
        else:
            sys.exit(
                'Unknown FIELD --> "{}" requested. Options are: Gabs/Eabs, Gth/Eth, Gph/Eph,\
                GL/EL, GR/ER, AR (skips eff. calculation).'.format(
                    field
                )
            )

        if not field == "AR":
            pattern, _ = self.fetch_field(
                pat_ind, eff_field, field_format="MA", rot_angles=rot_angles
            )
            vth, vph = utilities.get_angle_vectors(
                pattern, sphere_type="open", return_mesh=False
            )
            for i, angle in enumerate(vth):
                pattern[i, :] = pattern[i, :] * np.sin(angle)
            # Close the sphere:
            pattern = utilities.close_sphere(pattern)
            vth, vph = utilities.get_angle_vectors(
                pattern, sphere_type="closed", return_mesh=False
            )
            tot_field_power = np.trapz(np.trapz(pattern, vth, axis=0), vph) / (
                4 * np.pi
            )
        else:
            # total field power for Axial Ratio makes no sense...
            tot_field_power = -inf

        return tot_field_power

    def get_field_stats(
        self,
        pat_ind: int,
        field: str = "Gabs",
        analysis_range: list[int] = None,
        rot_angles: list[int] = None,
    ):
        """
        This method calculates several statistical metrics of a selected field. Based on pattern\
        index ``pat_ind`` and requested ``field``, the method calculates the minimum and maximum\
        of the field, the average value and the total power. In addition the calculation range can\
        be limited to only a portion of the field by specifying ``analysis_range`` as well as some\
        rotation can be performed in advance by specifying ``rot_angles``. The total field power is\
        always calculated for the full 3D sphere.

        Arguments:
            pat_ind (int): pattern index selected for analysis
            field (str): field selected for analysis. The field is selected via the strings defined\
                in :func:`~includes.field_operations.convert_field`. The default field is ``Gabs``.
            analysis_range ([int,int],[int,int]): four integers specifying the solid angle defined\
                for the analysis. The first two specify the Theta angle range and the second two\
                specify the Phi angle range. The default is [[0,180],[0,360]] defining a full 3D\
                sphere for analysis.
            rot_angles (int,int,int): defines the rotation Euler angles for the pattern to be \
                rotated before the analysis. ``analysis_range`` refers to the standard antenna \
                coordinate system as defined by IEEE - see [IEEESTDTest]_ and [IEEESTDTerms]_. \
                By default there is no rotation specified.

        Returns:
            tuple: four values with the analysis data in linear scale

                - tot_field_power (float): is the total field power as defined in \
                    :meth:`~includes.patterns.Patterns.get_tot_field_power`. This is always calculated for \
                    the full 3D sphere.
                -  min_field (float): the minimum value of the field after rotation and within\
                    the ``analysis_range`` defined.
                -  max_field (float): the maximum value of the field after rotation and within\
                    the ``analysis_range`` defined.
                -  avg_field (float): the average value of the field after rotation and within\
                    the ``analysis_range`` defined.

        Example:
            Suppose one has a patch antenna radiating along the Z axis and one is interested in the\
            antenna gain properties. One can call to :meth:`~includes.patterns.Patterns.get_field_stats` with the following \
            parameters::

                tot,min,max,avg = get_field_stats(0, analysis_range=[[0, 20], [0, 360]])

            This would return the total efficiency, the min, max and avg gains in the 0 to 20\
            Theta degrees solid angle and full Phi rotation. This is effectively looking at the\
            main beam lobe.

        """
        tot_field_power = self.get_tot_field_power(pat_ind, field, rot_angles)

        pat, _ = self.fetch_field(
            pat_ind, field, field_format="MA", rot_angles=rot_angles
        )
        pat = utilities.apply_analysis_range(pat, analysis_range)

        min_field: float = np.min(pat)
        max_field: float = np.max(pat)
        avg_field: float = np.mean(pat)

        return tot_field_power, min_field, max_field, avg_field

    def get_groups(self):
        """
        This method finds the groups of Patterns. Grouping is based on the source path. Files with\
        same source path belong to the same group. Groups are mostly useful when analyzing CST\
        parametric sweeps or multiple frequencies from same measurement. Groups can be used to\
        analyze multivariate parameter optimizations from parameteric analysis.

        Arguments:
            none

        Returns:
            tuple: returns two lists containing:

                - group_names (list): names of the groups. These are effectively the same as\
                    ``source`` parameter in the context.
                - memberidxs (list): the pattern indexes belonging to each group.
        """
        memberidxs = []
        sources = [self.patterns[s]["source"] for s in range(0, len(self.patterns))]

        group_names = list(set(sources))

        for g_nam in group_names:
            indices = [i for i, x in enumerate(sources) if x == g_nam]
            memberidxs.append(indices)
        return group_names, memberidxs

    def get_filtered_groups(self, patt_filter):
        """
        Same as :meth:`~includes.patterns.Patterns.get_groups` but it also applies a filter to the groups and removes any groups
        that are empty after the filter application.
        """
        group_names, memberidxs = self.get_groups()
        # apply filters
        for idx, gr_members in enumerate(list(memberidxs)):
            memberidxs[idx] = self.filter_patterns(patt_filter, gr_members)

        # Remove empty entries if any
        new_memberidxs = []
        new_gr_members = []
        for idx, mem in enumerate(memberidxs):
            if memberidxs[idx]:
                new_memberidxs.append(mem)
                new_gr_members.append(group_names[idx])
        memberidxs = new_memberidxs
        group_names = new_gr_members

        return group_names, memberidxs

    def filter_patterns(self, patt_filter, pat_inds=None):
        """
        Applies a filter to the Patterns specified in ``pat_inds`` and returns only the indexes that
        match.
        """
        if pat_inds is None:
            pat_inds = list(range(self.patterns.__len__()))
        pattern_filter = {"frequency": []}
        pattern_filter = utilities.update_params(pattern_filter, patt_filter)

        for pat in list(pat_inds):
            if (
                not pattern_filter["frequency"][0]
                <= self.patterns[pat]["frequency"]
                <= pattern_filter["frequency"][1]
            ):
                pat_inds.remove(pat)

        return pat_inds

    def get_group_stats(
        self, memberidxs, field="Gabs", analysis_range=None, rot_angles=None
    ):
        """
        This method generates statistics for entire groups. This is useful when analyzing for
        example the AR of a parameter sweep in CST and one is interested which set of parameters
        produces lowest average AR at maximum average gain given some ``analysis_range``.

        For each group the method scans the pattern indexes belonging to the groups and checks if
        the frequency is within the analysis range. Then the pattern is rotated if this is
        specified. The requested field is extracted and statistics are computed within the specified
        angular range using ``get_field_stats``. The results are appended to a group pool. Once all
        Patterns from a group are analyzed the group pool of results is further analyzed by
        computing min, max and average.

        Arguments:
            groupnames (list): names of the groups to be used - output form ``get_groups``.
            memberidxs (list): indexes of the Patterns in the groups - out form ``get_groups``.
            field (str): specified the field to be analyzed as described in ``fetch_field``.
            freq_range (list): start and stop frequencies (boundaries included) to search for in \
                the groups. The frequency must be defined in Hz. If a pattern is found within a\
                group that is within the frequency range it will be included in teh statistical\
                analysis.
            analysis_range (int,int,int,int): specifies start and stop theta and phi angles for\
                analysis from the full 3D field.
            rot_angles (int,int,int): three Euler angles defining the rotation of the fields.

        Returns:
            tuple: returns a tuple of four values in linear scale. The results are as below:

                - gr_tot_pwr (float): average total field power for all Patterns in the group. AR\
                    field does NOT have total power defined. The analysis is always done in full 3D\
                    sphere.
                - gr_min (float): minimum field value from all Patterns in the group. The\
                    analysis is done within the ``analysis_range``.
                - gr_max (float): maximum field value from all Patterns in the group. The\
                    analysis is done within the ``analysis_range``.
                - gr_avg (float): average field value from all Patterns in the group. The\
                    analysis is done within the ``analysis_range``.
        """
        gr_tot_pwr = []
        gr_min = []
        gr_max = []
        gr_avg = []
        for mems in memberidxs:

            t_stats = self.__get_single_group_stats(
                mems, field, analysis_range, rot_angles
            )

            if not t_stats.size == 0:
                gr_tot_pwr.append(np.mean(np.array(t_stats[:, 0])))
                gr_min.append(np.min(np.array(t_stats[:, 1])))
                gr_max.append(np.max(np.array(t_stats[:, 2])))
                gr_avg.append(np.mean(np.array(t_stats[:, 3])))
            else:
                gr_tot_pwr.append([])
                gr_min.append([])
                gr_max.append([])
                gr_avg.append([])

        return gr_tot_pwr, gr_min, gr_max, gr_avg

    def set_permanent_rotation_offset(self, pat_ind, rot_angles=None):
        """
        Applies permanent rotation offset to a pattern. This works by storing the rotation values
        for each pattern. Each time a pattern is fetched via ``fetch_field`` first the permanent
        rotation is applied effectively creating a new default orientation. The ``rot_angles``
        parameter of ``fetch_field`` then stacks additionally so that the total rotaions are added
        together.

        The definitions are the same as for ``fetch_field``.

        Arguments:
            pat_ind (int): pattern index rot_angles (int,int,int): three Euler angles of
            rotation.The order is --> [yaw, pitch, roll]. The default is [0,0,0], which means that\
                calling ``set_permanent_rotation_offset`` with only the ``pat_ind`` argument resets\
                any offsets applied earlier.

        Returns:
            bool: returns zero on successful execution.
        """
        if rot_angles is None:
            rot_angles = [0, 0, 0]

        self.patterns[pat_ind]["rot_offset"] = rot_angles

        return 0

    def prepare_for_plotting(
        self,
        pat_inds: list[int],
        field: str = "Gabs",
        rot_angles: list[int] = None,
        interp_resolution: list[int] = None,
    ):
        """
        Prepares selected far_fields for plotting. First it does interpolation and then creates a
        plotting object inputs that can be directly given to the plotting class constructor.

        Arguments:
            pat_inds (list): a list of integer indexes with the patterns to be processed. Use\
                ``list_patterns`` to identify the patters of interest.

            field (str): a string identifying the field to be used for plotting. See\
                :func:`~includes.field_operations.convert_field`

            rot_angles (:obj:`list` of three :obj:`int`, optional): a list of the rotation angles to be\
                used when generating the plotting object. All patterns will be rotated by these\
                values. To align only some patterns by applying some rotation use\
                :meth:`~includes.patterns.Patterns.set_permanent_rotation_offset`. For details on \
                how to define the rotation angles see :func:`~includes.field_operations.rotate`.

            interp_resolution (:obj:`list` of two :obj:`int`, optional): defines the interpolation\
                resolution. If the deault ``None`` is used the resolution will be taken from the\
                smallest per angle resolution from the selected patterns via ``pat_inds``.

        Returns:
            tuple: returns several variables:

                - fields_to_plot (:obj:`list`): a list of patterns prepated for plotting
                - phase_to_plot (:obj:`list`): a list of phases prepated for plotting where \
                    applicable
                - legend (:obj:`tuple` of :obj:`list`): a tuple of two lists containing ``field``\
                    and legend strings.
        """
        far_fields = self.__interpolate(pat_inds, interp_resolution)

        fields_to_plot: list[Any] = []
        phase_to_plot: list[Any] = []
        legend: list[str] = []

        for curr_p in far_fields:
            curr_p = field_operations.rotate(curr_p, rot_angles)
            t_field, t_phase = field_operations.convert_field(field, "MA", curr_p)
            fields_to_plot.append(t_field)
            phase_to_plot.append(t_phase)

        for curr_p in pat_inds:
            legend.append([field, " --> " + self.__create_legends(curr_p)])

        return fields_to_plot, phase_to_plot, legend

    def list_patterns(self):
        """
        Lists all Patterns legends with their corresponding indexes.

        Returns:
            list: returns a list of pattern legend strings and indexes.
        """
        pattern_list = []
        for curr_p in range(self.patterns.__len__()):
            pattern_list.append(
                "Index: " + str(curr_p) + " --> " + self.__create_legends(curr_p)
            )
        return pattern_list

    def compute_correlation(
        self, pat_inds, environment=None, rot_angles=None, corr_type="envelope"
    ):
        """
        Calculates the correlation coefficient between two radiation Patterns. The Patterns are
        specified as a vector of indexes and the output is a matrix with correlation values for each
        pattern index correlated with all others. This way, the diagonal of the matrix is always 1
        since it corresponds to correlation with self.

        Arguments:
            pat_inds (list): a list of the Patterns to be correlated
            environment (tuple): This is a tuple of two objects - a string and a dict. The \
                environment string for the power distribution function and its parameters. \
                Currently this is NOT used and always defaults to isotropic with XPD 1.
            rot_angles (tuple): tuple of the rotation angles as for all other functions. Based on\
                these the environment will be rotated similar to a radiation pattern and the\
                correlation will be computed afterwards. Since current environment is only \
                isotropic this makes no difference.
            corr_type (str): correlation to be returned. Default is ``envelope`` correlation. Also\
                possible is ``complex``.

        Returns:
            array: an array containing the correlation values - see example.

        Example:
            An example output is given in the table below, where the diagonal is always one. \
            This example is with the ``envelope`` output option.

            +--------+--------+--------+--------+--------+
            |        | pat1   |  pat2  |  pat3  |  pat4  |
            +========+========+========+========+========+
            |  pat1  |  1     |  0.5   |  0.2   |  0.6   |
            +--------+--------+--------+--------+--------+
            |  pat2  |  0.5   |  1     |  0.7   |  0.6   |
            +--------+--------+--------+--------+--------+
            |  pat3  |  0.2   |  0.7   |  1     |  0.8   |
            +--------+--------+--------+--------+--------+
            |  pat4  |  0.6   |  0.6   |  0.8   |  1     |
            +--------+--------+--------+--------+--------+
        """
        # Make sure to equalize the resolutions first via interpolation
        far_fields = self.__interpolate(pat_inds)

        # Generate the environment power distribution function
        env_pdp, xpd = field_operations.generate_environment(
            environment, shape=[far_fields[0].shape[1], far_fields[0].shape[2]]
        )
        env_pdp = field_operations.rotate(env_pdp, rot_angles)

        corr_table = np.zeros(
            (far_fields.__len__(), far_fields.__len__()), dtype=complex
        )
        corr_table[:] = np.nan

        for ind_1 in range(far_fields.__len__()):
            for ind_2 in range(far_fields.__len__()):

                corr_table[ind_1, ind_2] = field_operations.corelation_calculation(
                    far_fields[ind_1], far_fields[ind_2], env_pdp, xpd
                )

        if corr_type == "envelope":
            corr_table = np.abs(corr_table) ** 2

        return corr_table

    def compute_antenna_temperature(self, pat_inds, brightness_model=None):
        """
        Computes the antenna noise temperature of the radiation patterns selected with ``pat_inds``
        based on the ``brightness model``. The calculation is done as described in
        :func:`~includes.field_operations.antenna_temperature_calculation`

        Args:
            pat_inds (list): a list of indexes to the patterns for which the antenna temperature
                should be computed.
            brightness_model (dict): a python dictionary describing the noise temperature model -
                see :func:`~includes.field_operations.generate_brightness_temperature` for details.

        Returns:
            list: list of the calculated antenna temperature for each patterns indexed.\
                **NOTE** the returned temperature does NOT\
                include the contributions of the physical antenna temperature.
        """

        ant_temp = []

        for ind in pat_inds:
            g_abs, _ = self.fetch_field(ind, "Gabs", "MA")
            brightness_temperature = field_operations.generate_brightness_temperature(
                brightness_model, g_abs.shape
            )
            ant_temp.append(
                field_operations.antenna_temperature_calculation(
                    g_abs, brightness_temperature
                )
            )

        return ant_temp

    def remove_phase(self, pat_ind):
        """
        Warning:
            This method does a very artificial operation on a radiation pattern. Use with CARE!

        This method takes a pattern, removes all phase information from the electric fields (makes
        them all zeros) and appends the modified pattern as new.

        Arguments:
            pat_ind (int): the index of the pattern to be copied and altered
        Returns:
            int: appends a new Patterns to the structure and returns the new index
        """
        new_pat = self.patterns[pat_ind].copy()
        components = field_operations.get_far_field_components(new_pat["ff"])
        components[1] = np.zeros(components[1].shape, dtype=complex)
        components[3] = np.zeros(components[3].shape, dtype=complex)
        new_pat["ff"] = field_operations.combine_far_field_components(components)
        new_pat["file"] = "PHASE REMOVED --> " + new_pat["file"]
        self.patterns.append(new_pat)

        return len(self.patterns) - 1

    def normalize_pattern(self, pat_ind: int) -> int:
        """Normalize a pattern so that the total power is 1

        Normalizes a pattern so that the total power is 1 and appends the modified pattern as new.

        Arguments:
            pat_ind (int): the index of the pattern to be copied and altered
        Returns:
            int: appends a new pattern of type :class:`~includes.patterns.Patterns` to the structure and returns the \
                new index
        """

        # Determine the normalization coefficient
        total_field_power = self.get_tot_field_power(
            pat_ind=pat_ind, field="Gabs", rot_angles=None
        )
        g_norm = 1 / total_field_power

        new_pat = self.patterns[pat_ind].copy()
        components = field_operations.get_far_field_components(
            new_pat["ff"], method="RI"
        )
        components[0] = components[0] * np.sqrt(g_norm)
        components[1] = components[1] * np.sqrt(g_norm)
        components[2] = components[2] * np.sqrt(g_norm)
        components[3] = components[3] * np.sqrt(g_norm)
        new_pat["ff"] = field_operations.combine_far_field_components(
            components, method="RI"
        )
        new_pat["file"] = f'NORMALIZED --> {new_pat["file"]}'
        self.patterns.append(new_pat)

        return len(self.patterns) - 1

    def offset_efficiency(self, pat_ind: int, offset: float = 0) -> int:
        """Offset pattern efficiency by some gain in dB.

        Allows for an existing pattern to be offset in total efficiency by a positive or negative gain value.
        This is usefull if for example cable losses need to be taken in or out of the calibrated measurement.

        Note:
            Loss is always a positive number but gain can be both positive and negative!

            If a pattern was measured including an unnecessary patch cable having loss of 0.5 dB, the correct way to
            use this function is to enter this loss as a positive gain to be added to the pattern, resulting in a
            pattern with higher total efficiency by the value of the cable loss. This way the loss of the unnecessary
            patch cable is added to the measured pattern compensating for the cable loss present in the original
            measurement.

            Alternatively, if a pattern was measured excluding a necessary feed cable, with loss of 0.5 dB that needs
            to be accounted for, the correct way to use this function is to enter this loss as a negative gain to be
            removed from the measured pattern. This will result in a pattern with lower total efficiency. This way loss
            can be added to the pattern giving more accurate representation of the realized gain.

        Arguments:
            pat_ind (int): the index of the pattern to be copied and offset
            offset (float): the offset value to be applied. The offset must be specified in dB. Default is 0 dB.
        Returns:
            int: appends a new pattern of type :class:`~includes.patterns.Patterns` to the structure and returns the \
                new index
        """
        # Determine the normalization coefficient
        total_field_power = self.get_tot_field_power(
            pat_ind=pat_ind, field="Gabs", rot_angles=None
        )
        g_norm = (total_field_power * (10 ** (offset / 10))) / (total_field_power)

        new_pat = self.patterns[pat_ind].copy()
        components = field_operations.get_far_field_components(
            new_pat["ff"], method="RI"
        )
        components[0] = components[0] * np.sqrt(g_norm)
        components[1] = components[1] * np.sqrt(g_norm)
        components[2] = components[2] * np.sqrt(g_norm)
        components[3] = components[3] * np.sqrt(g_norm)
        new_pat["ff"] = field_operations.combine_far_field_components(
            components, method="RI"
        )
        new_pat["file"] = f'OFFSET by {offset} dB --> {new_pat["file"]}'
        self.patterns.append(new_pat)

        return len(self.patterns) - 1
